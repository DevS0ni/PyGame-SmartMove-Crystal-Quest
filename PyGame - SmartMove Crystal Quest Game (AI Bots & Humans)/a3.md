## Part D: Reflection

### Reflection for Sarah Haque

This was the one of the toughest assignments for me personally because of the complexity in Part B, normally we have a lot of test cases but this time around we only had 1 test cases and doing a complete code from that one case was a hard challenge Part A also had some challenges espically the implementation of overflow function was hard but after going through lectures and learning about trees I managed to complete Part A.

##### What I Did?
- I completed Part A of this Assignment after writing the evaluate_board function and adjust the overflow function that we did in first Assignment
- I wrote almost 50% of the code for Part B me and my partner worked together on this one we craved out some ideas and then implementation became easy I left some parts of the code for him and at the end when we integrated our codes it was working perfectly for us

##### Overall My Experience?
- I really liked this DSA456 course it was challenging and at the same time interesting I learned a lot from this.

### Reflection for Dev Soni

1. What exactly did you do for the assignment?
```
I implemented Part C of the assignment, which is an open-ended task to enhance the game. 
To be specific, I added features like "undo" for human players, animations for gem movements during overflow, 
and UI elements to adjust the smartness of AI bots. 
Additionally, we worked on Part B, specifically on the GameTree class and its initialization.
```

2. What was one thing you learned when doing this assignment?
```
From the implementation of coding, I learned about building a game tree for decision-making in games. 
This involves creating nodes for different game states, evaluating those states, and implementing the 
minimax algorithm for decision-making.
```

3. What was its most challenging aspect, and how did you overcome this challenge?
```
One challenging aspect could be the implementation of the minimax algorithm and the scoring mechanism for the game tree. 
It involves understanding and managing the complexity of evaluating different game states. 
To overcome this, you broke down the problem into smaller steps, implemented depth-first traversal for scoring nodes, 
and considered the even/odd level scoring based on the player making the move.
The addition of features to the game and the implementation of the game tree for decision-making, and the game building 
experience which I got was quite conviencing.
```

# LINK PART C FUNCTION EXPLANATION (YOUTUBE) - https://youtu.be/8P7K_g-BOTw?feature=shared
NOTE: Because of the video limit of 3 minutes, I did manage to explain the main functions I have added but
I still added other small extra functions which were not explained in video because of time limit.
